"use strict";(self.webpackChunksol_2_ink=self.webpackChunksol_2_ink||[]).push([[156],{3905:(t,e,r)=>{r.d(e,{Zo:()=>p,kt:()=>m});var n=r(7294);function i(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function o(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function a(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?o(Object(r),!0).forEach((function(e){i(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function s(t,e){if(null==t)return{};var r,n,i=function(t,e){if(null==t)return{};var r,n,i={},o=Object.keys(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||(i[r]=t[r]);return i}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(i[r]=t[r])}return i}var c=n.createContext({}),l=function(t){var e=n.useContext(c),r=e;return t&&(r="function"==typeof t?t(e):a(a({},e),t)),r},p=function(t){var e=l(t.components);return n.createElement(c.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},f=n.forwardRef((function(t,e){var r=t.components,i=t.mdxType,o=t.originalType,c=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),f=l(r),m=i,d=f["".concat(c,".").concat(m)]||f[m]||u[m]||o;return r?n.createElement(d,a(a({ref:e},p),{},{components:r})):n.createElement(d,a({ref:e},p))}));function m(t,e){var r=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var o=r.length,a=new Array(o);a[0]=f;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:i,a[1]=s;for(var l=2;l<o;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},3917:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=r(7462),i=(r(7294),r(3905));const o={sidebar_position:3,title:"Parsing a contract"},a=void 0,s={unversionedId:"how_it_works/parsing_contract",id:"how_it_works/parsing_contract",title:"Parsing a contract",description:"Another case is parsing of a contract, which will start if the program finds a contract definition. While parsing a contract, the program looks for the following:",source:"@site/docs/how_it_works/parsing_contract.md",sourceDirName:"how_it_works",slug:"/how_it_works/parsing_contract",permalink:"/how_it_works/parsing_contract",draft:!1,editUrl:"https://github.com/Supercolony-net/sol2ink/tree/main/docs/docs/how_it_works/parsing_contract.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Parsing a contract"},sidebar:"tutorialSidebar",previous:{title:"Parsing an interface",permalink:"/how_it_works/parsing_interface"},next:{title:"Parsing functions",permalink:"/how_it_works/parsing_functions"}},c={},l=[{value:"Parsing a function or a modifier",id:"parsing-a-function-or-a-modifier",level:3}],p={toc:l};function u(t){let{components:e,...r}=t;return(0,i.kt)("wrapper",(0,n.Z)({},p,r,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Another case is parsing of a contract, which will start if the program finds a contract definition. While parsing a contract, the program looks for the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"event definitions"),(0,i.kt)("li",{parentName:"ul"},"struct definitions"),(0,i.kt)("li",{parentName:"ul"},"enum definitions"),(0,i.kt)("li",{parentName:"ul"},"function definitions"),(0,i.kt)("li",{parentName:"ul"},"documentation comments"),(0,i.kt)("li",{parentName:"ul"},"state variables"),(0,i.kt)("li",{parentName:"ul"},"constructor"),(0,i.kt)("li",{parentName:"ul"},"modifiers")),(0,i.kt)("h3",{id:"parsing-a-function-or-a-modifier"},"Parsing a function or a modifier"),(0,i.kt)("p",null,"In this first step of parsing, the program parses the body of a function or a modifier to a raw statement, which is a statement which ends either with a curly bracket or with a semicolon. These raw statements will be then parsed into actual Rust and ink! code in the final step, and it is done this way, so the program knows when working with an expression, whether the expression is a constant, state variable, etc."),(0,i.kt)("p",null,"Once the program reaches the end of the contract, now it's time to parse the bodies of functions and modifiers."))}u.isMDXComponent=!0}}]);