"use strict";(self.webpackChunksol_2_ink=self.webpackChunksol_2_ink||[]).push([[495],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(h,a(a({ref:t},p),{},{components:n})):r.createElement(h,a({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},942:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const i={sidebar_position:4,title:"Parsing functions"},a=void 0,s={unversionedId:"how_it_works/parsing_functions",id:"how_it_works/parsing_functions",title:"Parsing functions",description:"Now the parser knows every contract member and has the information about what the Solidity statements of functions and modifiers look like, in the form of Statement::Raw, so we will parse them into the correct format. For every statement, we will check which statement does it fit.",source:"@site/docs/how_it_works/parsing_functions.md",sourceDirName:"how_it_works",slug:"/how_it_works/parsing_functions",permalink:"/how_it_works/parsing_functions",draft:!1,editUrl:"https://github.com/Supercolony-net/sol2ink/tree/main/docs/docs/how_it_works/parsing_functions.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Parsing functions"},sidebar:"tutorialSidebar",previous:{title:"Parsing a contract",permalink:"/how_it_works/parsing_contract"},next:{title:"Parsing expressions",permalink:"/how_it_works/parsing_expressions"}},l={},c=[{value:"_",id:"_",level:3},{value:"Return statement",id:"return-statement",level:3},{value:"Require",id:"require",level:3},{value:"Emit event",id:"emit-event",level:3},{value:"Ternary operator",id:"ternary-operator",level:3},{value:"Binary operation",id:"binary-operation",level:3},{value:"Loops",id:"loops",level:3},{value:"Unchecked blocks",id:"unchecked-blocks",level:3},{value:"Try/catch blocks",id:"trycatch-blocks",level:3},{value:"Assembly blocks",id:"assembly-blocks",level:3}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Now the parser knows every contract member and has the information about what the Solidity statements of functions and modifiers look like, in the form of ",(0,o.kt)("inlineCode",{parentName:"p"},"Statement::Raw"),", so we will parse them into the correct format. For every statement, we will check which statement does it fit."),(0,o.kt)("h3",{id:"_"},"_"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_")," implies that at this point body of the modifier should be executed. So the program parses it as ",(0,o.kt)("inlineCode",{parentName:"p"},"Statement::ModifierBody"),"."),(0,o.kt)("h3",{id:"return-statement"},"Return statement"),(0,o.kt)("p",null,"The mission is simple - to return a value. The functions of the generated contract will always return ",(0,o.kt)("inlineCode",{parentName:"p"},"Result<T, Error>"),", where ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," is the return type of the function (",(0,o.kt)("inlineCode",{parentName:"p"},"()")," if the function has no return type). We wrap the output in a result because if we want to revert a call, we need to return an error. And that is, of course, possible if we return ",(0,o.kt)("inlineCode",{parentName:"p"},"Result"),". The error type returned in the Result is declared in the final contract, but more on that later."),(0,o.kt)("h3",{id:"require"},"Require"),(0,o.kt)("p",null,"Require statements are not available in Rust and ink!, so Sol2Ink will parse them as an if statement and return an error. But the require statement requires the condition to be true so that Sol2Ink will parse it as an inverted condition. Meaning ",(0,o.kt)("inlineCode",{parentName:"p"},"require(true)")," will be parsed as "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Rust"},"if(false) {\n    return Err(Error(String::new()))\n}\n")),(0,o.kt)("p",null,"If the error message were defined in the Solidity contract, Sol2Ink would use this error message in the ink! contract as well, but if it were not provided, Sol2Ink would provide its error message."),(0,o.kt)("h3",{id:"emit-event"},"Emit event"),(0,o.kt)("p",null,"Here we need to note that events in ink! are structs with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ink[(event)]")," attribute. So emitting an event is just calling of ",(0,o.kt)("inlineCode",{parentName:"p"},"emit_event")," function, providing a new struct with the desired parameters."),(0,o.kt)("h3",{id:"ternary-operator"},"Ternary operator"),(0,o.kt)("p",null,"The ternary operator does not exist in Rust, so they are parsed as an if/else block."),(0,o.kt)("h3",{id:"binary-operation"},"Binary operation"),(0,o.kt)("p",null,"Binary operations ++ and -- are not available in Rust, so we parse them as addition or subtraction of 1. Depending on if the operation were a prefix or suffix operation, we would do the incrementation/subtraction before or after reading the value."),(0,o.kt)("h3",{id:"loops"},"Loops"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For loops are parsed to while loops, with the incrementation happening at the end of the loop. "),(0,o.kt)("li",{parentName:"ul"},"Do/while loops are parsed as a loop with a condition check at the end of the block. "),(0,o.kt)("li",{parentName:"ul"},"While loops are parsed as while loops ")),(0,o.kt)("h3",{id:"unchecked-blocks"},"Unchecked blocks"),(0,o.kt)("p",null,"A comment to check if everything is correct is inserted at the unchecked block's beginning and end."),(0,o.kt)("h3",{id:"trycatch-blocks"},"Try/catch blocks"),(0,o.kt)("p",null,"Try block is parsed as an ",(0,o.kt)("inlineCode",{parentName:"p"},"if true")," block, adding the original try statement as a comment. Catch blocks are parsed as ",(0,o.kt)("inlineCode",{parentName:"p"},"else if false")," blocks, adding the original catch statement as a comment."),(0,o.kt)("h3",{id:"assembly-blocks"},"Assembly blocks"),(0,o.kt)("p",null,"Sol2Ink parses assembly blocks as comments."),(0,o.kt)("p",null,"All other statements are parsed as expected:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"declarations"),(0,o.kt)("li",{parentName:"ul"},"comments"),(0,o.kt)("li",{parentName:"ul"},"conditional blocks and one-line conditions"),(0,o.kt)("li",{parentName:"ul"},"assignments"),(0,o.kt)("li",{parentName:"ul"},"function calls")),(0,o.kt)("p",null,"If So2Ink reaches some specific statement that it cannot parse yet, it will parse it as a comment with a notice ",(0,o.kt)("inlineCode",{parentName:"p"},"Sol2Ink Not Implemented yet"),"."))}u.isMDXComponent=!0}}]);